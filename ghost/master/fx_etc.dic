OnInstallBegin
{
	"\0\b[0]"
	--
	if ISFUNC("OnCustom_ActionSurfaces") && CustomFuncs[0] == 1; "\![embed,OnCustom_ActionSurfaces,Action]"
	else; "\s[6]"
	--
	if language == "Placeholder" //TRANSLATORS: Beginning an installation
	{
		
	}
	elseif language == "Deutsch"
	{
		"[Installationsvorgang wird gestartet...]\e"
	}
	elseif language == "Русский"
	{
		"[Начинает установление...]\e"
	}
	elseif language == "Français"
	{
		"[Début de l'installation...]\e"
	}
	elseif language == "Polski"
	{
		"[Zaczynam instalacje...]\e"
	}
	else //English
	{
		"[Beginning installation...]\e"
	}
}

//Finished installing something ghost related. You can remove any of the ifs here if you like, and just have it go to the else.
//reference0 is the type of installed item, reference1 is the name.
OnInstallComplete : all
{
	"\0\b[0]"
	--
	if ISFUNC("OnCustom_ActionSurfaces") && CustomFuncs[0] == 1; "\![embed,OnCustom_ActionSurfaces,Action]"
	else; "\s[6]"
	--
	if reference0 == "ghost"
	{
		if language == "Placeholder" //TRANSLATORS: When a ghost has finished installing. reference1 is the name of the installed ghost
		{
			
		}
		elseif language == "Español"
		{
			"['%(reference1)' instalado con éxito.]\n\n"
			
			"\![*]\q[Llamar %(reference1),CallGhost]\n"
			"\![*]\q[Cambiar a %(reference1),ChangeToGhost]\n\n"
			"\![*]\q[Cerrar,OnCancel]"
		}
		elseif language == "Deutsch"
		{
			"['%(reference1)' wurde erfolgreich installiert.]\n\n"
			
			"\![*]\q[%(reference1) rufen,CallGhost]\n"
			"\![*]\q[Zu %(reference1) wechseln,ChangeToGhost]\n\n"
			"\![*]\q[Schließen,OnCancel]"
		}
		elseif language == "Русский"
		{
			"[Установил '%(reference1)'.]\n\n"
			
			"\![*]\q[Вызвать %(reference1),CallGhost]\n"
			"\![*]\q[Сменить в %(reference1),ChangeToGhost]\n\n"
			"\![*]\q[Закрыть,OnCancel]"
		}
		elseif language == "Français"
		{
			"['%(reference1)' installé avec succès.]\n\n"
			
			"\![*]\q[Appeler %(reference1),CallGhost]\n"
			"\![*]\q[Changer pour %(reference1),ChangeToGhost]\n\n"
			"\![*]\q[Fermer,OnCancel]"
		}
		elseif language == "Polski"
		{
			"[Zainstalowałem '%(reference1)'.]\n\n"
			
			"\![*]\q[Przywołaj %(reference1),CallGhost]\n"
			"\![*]\q[Zmień na %(reference1),ChangeToGhost]\n\n"
			"\![*]\q[Zamknij,OnCancel]"
		}
		else //English
		{
			"[Successfully installed '%(reference1)'.]\n\n"
			
			"\![*]\q[Call %(reference1),CallGhost]\n"
			"\![*]\q[Change to %(reference1),ChangeToGhost]\n\n"
			"\![*]\q[Close,OnCancel]"
		}
	}
	elseif reference0 == "shell"
	{
		if language == "Placeholder" //TRANSLATORS: When a shell has finished installing. reference1 is the name of the installed shell
		{
			
		}
		elseif language == "Español"
		{
			"['%(reference1)' instalado con éxito.]\n\n"
			
			"\![*]\q[Cambiar a %(reference1),OnChangeToShell]\n\n"
			"\![*]\q[Cerrar,OnCancel]"
		}
		elseif language == "Deutsch"
		{
			"['%(reference1)' wurde erfolgreich installiert.]\n\n"
			
			"\![*]\q[Zu %(reference1) wechseln,OnChangeToShell]\n\n"
			"\![*]\q[Schließen,OnCancel]"
		}
		elseif language == "Русский"
		{
			"[Установил '%(reference1)'.]\n\n"
			
			"\![*]\q[Сменить в  %(reference1),OnChangeToShell]\n\n"
			"\![*]\q[Закрыть,OnCancel]"
		}
		elseif language == "Français"
		{
			"['%(reference1)' installé avec succès.]\n\n"
			
			"\![*]\q[Changer pour %(reference1),OnChangeToShell]\n\n"
			"\![*]\q[Fermer,OnCancel]"
		}
		elseif language == "Polski"
		{
			"[Zainstalowałem '%(reference1)'.]\n\n"
			
			"\![*]\q[Zmień na %(reference1),OnChangeToShell]\n\n"
			"\![*]\q[Zamknij,OnCancel]"
		}
		else //English
		{
			"[Successfully installed '%(reference1)'.]\n\n"
			
			"\![*]\q[Change to %(reference1),OnChangeToShell]\n\n"
			"\![*]\q[Close,OnCancel]"
		}
	}
	else
	{
		if language == "Placeholder" //TRANSLATORS: Generic install finished dialogue. reference1 is the name of the installed thing
		{
			
		}
		elseif language == "Español"
		{
			"['%(reference1)' instalado con éxito.]\e"
		}
		elseif language == "Deutsch"
		{
			"['%(reference1)' wurde erfolgreich installiert.]\e"
		}
		elseif language == "Русский"
		{
			"[Установил '%(reference1)'.]\e"
		}
		elseif language == "Français"
		{
			"['%(reference1)' installé avec succès.]\e"
		}
		elseif language == "Polski"
		{
			"[Zainstalowałem '%(reference1)'.]\e"
		}
		else //English
		{
			"[Successfully installed '%(reference1)'.]\e"
		}
	}
}

//Calling the ghost that was just installed. Add dialogues to these if you like.
Select.CallGhost
{
	"\![call,ghost,lastinstalled]\e"
}

//Opening the ghost that was just installed.
Select.ChangeToGhost
{
	"\![change,ghost,lastinstalled]\e"
}

OnChangeToShell
{
	"\![get,property,OnGetCoords,currentghost.scope(0).rect]"
	--
	if reference0 != ""; "\![change,shell,%(reference0)]\e"
	else; "\![change,shell,lastinstalled]\e"
}

//reference0 is the reason the install failed
OnInstallFailure //If the install fails
{
	"\0\b[0]"
	--
	if ISFUNC("OnCustom_ActionSurfaces") && CustomFuncs[0] == 1; "\![embed,OnCustom_ActionSurfaces,Error]"
	else; "\s[6]"
	--
	if reference0 == "artificial" //If the user cancels by double clicking the balloon
	{
		if ISFUNC("OnCustom_ActionSurfaces") && CustomFuncs[0] == 1; "\![embed,OnCustom_ActionSurfaces,Action]"
		else; "\s[6]"
		--
		if language == "Placeholder" //TRANSLATORS: When the user cancels the installation
		{
			
		}
		elseif language == "Español"
		{
			"[Instalación cancelada.]\e"
		}
		elseif language == "Deutsch"
		{
			"[Installationsvorgang wurde abgebrochen.]\e"
		}
		elseif language == "Русский"
		{
			"[Установление отменил.]\e" //кто это делали? может, отменил_а...
		}
		elseif language == "Français"
		{
			"[Installation annulée]\e"
		}
		elseif language == "Polski"
		{
			"[Instalacja anulowana.]\e"
		}
		else //English
		{
			"[Cancelled installation.]\e"
		}
	}
	else
	{
		if language == "Placeholder" //TRANSLATORS: If the installation failed. reference0 is the reason why it failed
		{
			
		}
		elseif language == "Español"
		{
			"[No se ha podido realizar la instalación.\w8\w8 '%(reference0)'.]\e"
		}
		elseif language == "Deutsch"
		{
			"[Installation fehlgeschlagen.\w8\w8 '%(reference0)'.]\e"
		}
		elseif language == "Русский"
		{
			"[Не удалось установить.\w8\w8 '%(reference0)'.]\e"
		}
		elseif language == "Français"
		{
			"[L'installation a échouée.\w8\w8 '%(reference0)'.]\e"
		}
		elseif language == "Polski"
		{
			"[Instalacja się nie udała.\w8\w8 '%(reference0)'.]\e"
		}
		else //English
		{
			"[The installation failed.\w8\w8 '%(reference0)'.]\e"
		}
	}
}

OnFileDropping //When the user is holding a file over FLUX, before it's dropped
{
	DraggedFile = reference0 //This is for converting FLELE shells
}

OnInstallReroute //When you try to install a file meant for another ghost, and that ghost is also running
{
	"\0\b[0]"
	--
	if reference0 == "flele" && reference1 == "shell"
	{
		if ISFUNC("OnCustom_ActionSurfaces") && CustomFuncs[0] == 1; "\![embed,OnCustom_ActionSurfaces,Refuse]"
		else; "\s[6]"
	}
	else
	{
		if ISFUNC("OnCustom_ActionSurfaces") && CustomFuncs[0] == 1; "\![embed,OnCustom_ActionSurfaces,Error]"
		else; "\s[6]"
	}
	--
	if language == "Placeholder" //TRANSLATORS: This is if the user tries to install a file for another ghost while the other ghost is running. Rather than copy over the function from below, since I think that'd feel weird in practice, I'm going to have it direct the user to close FLELE in order to install FLELE shells. reference1 is the type of item you tried to install, reference0 is the sakura name of the ghost it's compatible with
	{
		
	}
	elseif language == "Español"
	{
		if reference0 == "flele" && reference1 == "shell"
		{
			"[Este Shell solo está disponible para instalar en FLELE.\w8\w8 Puede ser instalado en FLUX,\w4 pero debes cerrar FLELE primero.\w8\w8 Como alternativa,\w4 puedes modificar el archivo install.txt del Shell para eliminar la restricción.]\e"
		}
		else
		{
			"[%(reference1) solo es compatible con %(reference0).]\e"
		}
	}
	elseif language == "Deutsch"
	{
		if reference0 == "flele" && reference1 == "shell"
		{
			"[Diese Shell ist darauf eingestellt nur von FLELE installiert zu werden.\w8\w8 Sie kann auch von FLUX installiert werden\w4 aber dazu musst du FLELE erst schließen.\w8\w8 Du kannst stattdessen auch das install.txt der Shell bearbeiten um diese Beschränkung zu entfernen.]\e"
		}
		else //Other ghosts
		{
			"[Diese Shell ist ausschließlich mit %(reference0) kompatibel.]\e"
		}
	}
	elseif language == "Русский"
	{
		if reference0 == "flele" && reference1 == "shell"
		{
			"[Только FLELE можно установить этот Внешний Вид.\w8\w8 Зато FLUX все-таки может установить,\w4 но впервые, ты должен закрыть FLELE.\w8\w8 Ты  также можешь изменить install.txt этого вида, чтобы отчистить этот недостаток.]\e"
		}
		else //Other ghosts
		{
			"[Этот %(reference1) только совместимый с %(reference0).]\e"
		}
	}
	elseif language == "Français"
	{
		if reference0 == "flele" && reference1 == "shell"
		{
			"[Ce shell a été fait pour n'être installé que pour FLELE.\w8\w8 FLUX peut tout de même l'installer,\w4 mais tu dois fermer FLELE en premier.\w8\w8 Sinon,\w4 tu peux aussi modifier le install.txt du shell pour enlever la restriction.]\e"
		}
		else //Other ghosts
		{
			"[Ce %(reference1) est compatible avec %(reference0) seulement.]\e"
		}
	}
	elseif language == "Polski"
	{
		if reference0 == "flele" && reference1 == "shell"
		{
			"[Ta skorupa jest ustawiona by tylko się instalować na FLELE.\w8\w8 It can still be installed by FLUX,\w4 but you must close FLELE first.\w8\w8 Alternatively,\w4 you can alter the install.txt of the shell to remove the restriction.]\e"
		}
		else
		{
			"[Ten plik jest kompatybilny tylko z %(reference0).]\e"
		}
	}
	else //English
	{
		if reference0 == "flele" && reference1 == "shell"
		{
			"[This shell is set to install only for FLELE.\w8\w8 It can still be installed by FLUX,\w4 but you must close FLELE first.\w8\w8 Alternatively,\w4 you can alter the install.txt of the shell to remove the restriction.]\e"
		}
		else //Other ghosts
		{
			"[This %(reference1) is compatible with %(reference0) only.]\e"
		}
	}
}

//reference0 is the Sakura name of the ghost the item was meant for, reference1 (since SSP 2.4.85) is the type of item you tried to install
OnInstallRefuse
{
	if reference0 == "flele" && reference1 == "shell" //If this is meant for FLELE, then FLUX will convert it so that you can install it
	{
		//Ok look, I gotta talk about all this nonsense below, because HAHA THIS WAS A PAIN AND ITS KINDA JANKY BUT IT WORKS OK
		//So here's the deal. UNFORTUNATELY, most FLELE shells are set up such that ONLY FLELE will install them, and other ghosts will refuse. But! Thanks to the magic of OnFileDropping, I was able to grab the file path of the .nar file you just dropped. Then, if it sees it's supposed to be for FLELE, it does all this stuff!
		//First, it copies the .nar file into its shell folder. It renames it to a .zip (I'm not sure if this step is actually necessary but I'm not gonna fuss with it now), then it uses a SAORI I found (@the person who made the SAORI, I love you so much) to unzip the contents. It deletes the copied archive since we don't need it, then it scans through the install.txt to get the name and directory. It saves the name for after it reloads, and it renames the folder to what the directory is supposed to be called.
		//Then, after it reloads, OnSecondChange sees that the InstalledNewShell variable is not empty, and brings up a dialogue box for having installed a new shell. Tada! Got around the FLELE only problem! Hahahahaha this is so janky XD I can't believe this works.
		//I should probably add some sort of error handling or something???
		
		//Possible errors that need to be handled:
		// -Zarc fails
		// -Copying or opening the install.txt fails
		// -It can't find the install.txt because it's nested in a stupid amount of directories
		// -There is no name or directory in the install.txt
		// -If the directory it wants to make already exists
		
		if FENUM("../../temp/") == ""; void MKDIR("../../temp/")
		else; void OnEmptyTempFolder
		
		_temppath = "../../temp/"
		_path = "../../shell/"
		_f = FCOPY(DraggedFile,_temppath) //Copy the file that was dropped
		if _f == 0; {"\![raise,OnShellInstallFailure,can't copy]"; return}
		_name = SPLITPATH(DraggedFile)[2] //Get the name and extension
		_ext = SPLITPATH(DraggedFile)[3]
		
		_r = FRENAME("%(_temppath)%(_name)%(_ext)","%(_temppath)%(_name).zip") //Rename it to a .zip
		if _r == 0
		{
			_del = FDEL("%(_temppath)%(_name)%(_ext)")
			"\![raise,OnShellInstallFailure,can't rename to a zip## folder with same name may already exist,%(_del)]"
			return
		}
		_i = FUNCTIONEX("zarc.dll","unzip","%(_temppath)%(_name).zip","%(_temppath)%(_name)/") //Unzip it
		if _i != ""; {"\![raise,OnShellInstallFailure,can't extract: %(_i)]"; return}
		_f = FDEL("%(_temppath)%(_name).zip") //Delete the archive since we have the contents in a folder now
		
		_dir = "%(_temppath)%(_name)/"
		_file = ""
		_i = 0
		_nested = ""
		_dirfound = 0
		while _dirfound == 0
		{
			if _i > 10; break
			
			_test = FENUM(_dir + _nested)
			
			if ARRAYSIZE(_test) == 1; _nested += REPLACE(_test,"\","/")
			elseif "install.txt" _in_ _test; {_file = "%(_dir)%(_nested)/install.txt"; _dirfound = 1}
			else
			{
				break
			}
			_i++
		}
		-- //==
		if _dirfound == 0 //probably need to delete the copied file/directory
		{
			//_del = RMDIREX(_dir)
			"\![raise,OnShellInstallFailure,can't find install.txt,%(_del)]" //THIS ISN'T DONE, HAVE TO FIGURE OUT HOW TO DELETE THE DIRECTORY. TODO FINISH THIS - want to maybe make it use a temp folder instead
			//Did I finish this???? Idk man
			return
		}
		else //If the proper directory was found
		{
			//_file = "%(_path)%(_name)/install.txt" //Initialize loop variables
			_found = ""
			InstalledShellName = ""
			
			_o = FOPEN(_file,"r")
			--
			for _buff = FREAD(_file); _buff != -1; _buff = FREAD(_file) //Loop through to get the name and directory
			{
				if "directory," _in_ _buff; _found = CUTSPACE(_buff[1])
				if "name," _in_ _buff; InstalledShellName = CUTSPACE(_buff[1]) //Note, by putting something into InstalledShellName, it will trigger the dialogue in OnSecondChange after reloading
			}
			--
			_f = FCLOSE(_file)
			
			if _found != ""
			{
				if "/%(_found)" _in_ REPLACE(FENUM(_path,"|"),"\","/") //If a folder with this name exists already
				{
					"\![raise,OnShellInstallFailure,can't move directory## folder with the target name already exists,%(_mov),%(_del),%(_del2)]"
					return
				}
				
				if _i > 0 //If this is a nested folder
				{
					_mov = OnMoveFolder("%(_dir)%(_nested)","%(_path)%(_found)/")
					//_del = RMDIREX(_dir)
					
					if _mov != 1
					{

						_del2 = RMDIREX("%(_temppath)%(_found)/")
						"\![raise,OnShellInstallFailure,can't un-nest the directory## something went wrong while moving,%(_mov),%(_del),%(_del2)]"
						return
					}
				}
				else
				{
					_mov = OnMoveFolder("%(_temppath)%(_name)/","%(_path)%(_found)/") //Rename the folder to match the directory name in install.txt (minus any spaces on the left and right)
					//_r = FRENAME("%(_path)%(_name)/","%(_path)%(_found)/") 
					if _mov == 0
					{
						//_del = RMDIREX(_dir)
						"\![raise,OnShellInstallFailure,can't move folder to shell directory.,%(_del)]"
						return
					}
				}
			}
			else;
			{
				//_del = RMDIREX(_dir)
				"\![raise,OnShellInstallFailure,can't find name/directory in install.txt,%(_del)]" //ALSO NEED TO REMOVE DIRECTORY IN THIS CASE, TODO
				return
			}
			
			if _o == 1 && InstalledShellName != "" //If the file opened successfully and a name exists, it must have installed properly, so go ahead and reload
			{
				"\![raise,OnStopSong,reload]\![reload,ghost]"
			}
			else
			{
				"\0\b[0]"
				--
				if ISFUNC("OnCustom_ActionSurfaces") && CustomFuncs[0] == 1; "\![embed,OnCustom_ActionSurfaces,Error]"
				else; "\s[6]"
				--
				if language == "Placeholder" //TRANSLATORS: If the user tries to install a FLELE only shell, and it fails for some reason
				{
					
				}
				elseif language == "Español"
				{
					"[El Shell no ha podido ser instalado.\w8 Por favor extraiga el archivo,\w4 diríjase al archivo install.txt\w4 y elimine la línea 'accept,flele'.\w8 Comprima el archivo como .zip\w4 e inténtelo de nuevo.]\e"
				}
				elseif language == "Deutsch"
				{
					"[Die Shell konnte nicht installiert werden.\w8 Bitte extrahiere das Archiv,\w4 gehe zu install.txt\w4 und entferne die Zeile 'accept,flele'.\w8 Dann komprimiere den Ordner wieder\w4 und versuche es nochmal.]\e"
				}
				elseif language == "Русский"
				{
					"[Не удалось установить вид.\w8 Пожалуйста, извлечь его,\w4 перейти в install.txt,\w4 и удалить строк 'accept,flele'.\w8 Затем вновь его архировать,\w4 и попробуй еще раз.]\e"
				}
				elseif language == "Français"
				{
					"[N'aie pas pu installer le shell.\w8 Stp extrais l'archive,\w4 va dans l'install.txt,\w4 et supprime la ligne 'accept,flele'.\w8 Puis zip-le,\w4 et essaye à nouveau.]\e"
				}
				elseif language == "Polski"
				{
					"[Nie można zainstalować skorupy.\w8 Proszę rozpakować archiwum,\w4 przejdź do pliku install.txt,\w4 i usuń linię 'accept,flele'.\w8 Następnie zapakuj je ponownie\w4 i spróbuj jeszcze raz.]\e"
				}
				else //English
				{
					"[Could not install the shell.\w8 Please extract the archive,\w4 go into install.txt,\w4 and remove the line 'accept,flele'.\w8 Then zip it,\w4 and try it again.]\e"
				}
			}	
		}
	}
	else
	{
		"\0\b[0]"
		--
		if ISFUNC("OnCustom_ActionSurfaces") && CustomFuncs[0] == 1; "\![embed,OnCustom_ActionSurfaces,Error]"
		else; "\s[6]"
		--
		if language == "Placeholder" //TRANSLATORS: If the user tries to install something that's only compatible with another ghost. reference1 is the type of thing they tried to install, reference0 is the sakura name of the other ghost
		{
			
		}
		elseif language == "Español"
		{
			"[%(reference1) no ha podido ser instalado.\w4 Solo es compatible con %(reference0).]\e"
		}
		elseif language == "Deutsch"
		{
			_r = ""
			_es = ""
			if TOLOWER(reference1) == "shell" || TOLOWER(reference1) == "headline"
			{
				_r = ""
				_es = "sie"
			}
			elseif TOLOWER(reference1) == "ghost" || TOLOWER(reference1) == "balloon" || TOLOWER(reference1) == "calendar skin"
			{
				_r = "r"
				_es = "er"
			}
			else
			{
				_r = "s"
				_es = "es"
			}
			--
			"Diese%(_r) %(Capitalize(reference1)) konnte nicht installiert werden,\w4 %(_es) ist nur mit %(reference0) kompatibel.]\e"
		}
		elseif language == "Русский"
		{
			"[Не удалось установить этот %(reference1),\w4 поэтому и совместимый только с %(reference0).]\e"
		}
		elseif language == "Français"
		{
			"[Impossible d'installer %(reference1),\w4 c'est compatible uniquement avec %(reference0).]\e"
		}
		elseif language == "Polski"
		{
			_temp = ""
			if TOLOWER(reference1) == "shell"
			{
				_temp = "tej skorupy"
			}
			else
			{
				_temp = "tego pliku"
			}
			--
			"[Nie moge zainstalować %(_temp),\w4 jest on kompatybilny tylko z %(reference0).]\e"
		}
		else //English
		{
			"[Cannot install this %(reference1),\w4 it is compatible only with %(reference0).]\e"
		}
	}
}

OnEmptyTempFolder
{
	_dir = "../../temp/"
	
	if FENUM(_dir,"|") == ""; {1; return}
	_error = ""
	_files = SPLIT(FENUM(_dir,"|"),"|")
	foreach _files; _file
	{
		_enum = FENUM("%(_dir)%(_file)","|")
		if _enum != ""
		{
			_del = RMDIREX("%(_dir)%(_file)")
			if _del == 0; {_error = "Can't delete directory %(_dir)%(_file) with RMDIREX"; break}
		}
		else
		{
			_del = FDEL("%(_dir)%(_file)")
			if _del == 0;
			{
				_del = RMDIR("%(_dir)%(_file)")
			}
			if _del == 0; {_error = "Can't delete file %(_dir)%(_file)"; break}
		}
	}
	
	void RMDIR(_dir)
	
	if _error == ""; 1
	else; _error
}

//Searches for and deletes files in a folder, then deletes the folder itself. Also goes into subfolders and does the same thing. Recursive function, use wisely.
RMDIREX
{
	_input = FENUM(_argv[0],"|") //Enumerate the folder
	
	if _input != "" //If this is not an empty folder
	{
		_input = SPLIT(_input,"|") //Split the folder into an array
		
		foreach _input; _file
		{
			_path = SPLITPATH(_file)
			_ext = TOLOWER(_path[3])
			
			if _ext != "" //If it's not a folder
			{
				_del = FDEL("%(_argv[0])\%(_file)")
				if _del != 1; {"Couldn't delete file \_?%(_argv[0])%(_file)\_?"; return}
			}
			else //If it's a folder
			{
				_recursive = RMDIREX("%(_argv[0])\%(_file)")
				if _recursive != 1; {"Recursive call failed: %(_recursive)"; return}
			}
		}
	}
	_del = RMDIR(_argv[0])
	
	if _del == 1; 1
	else; "Couldn't delete directory"
}

//Moves a folder up into a new directory. Used to get rid of nested folders. _argv[0] is the origin folder, _argv[1] is the new folder
OnMoveFolder
{
	_input = FENUM(_argv[0],"|") //Enumerate the folder
	_f = MKDIR(_argv[1]) //Make the new folder
	
	if _input != "" //If this is not an empty folder
	{
		_input = SPLIT(_input,"|") //Split the folder into an array
		
		foreach _input; _file
		{
			_path = SPLITPATH(_file)
			_ext = TOLOWER(_path[3])
			
			if _ext != "" //If it's not a folder
			{
				_mov = FMOVE("%(_argv[0])\%(_file)","%(_argv[1])")
				if _mov != 1; {"Couldn't move file \_?%(_argv[0])%(_file)\_?"; return}
			}
			else //If it's a folder
			{
				_recursive = OnMoveFolder("%(_argv[0])\%(_file)","%(_argv[1])\%(_file)")
				if _recursive != 1; {"Recursive call failed: %(_recursive)"; return}
			}
		}
	}
	
	_del = RMDIR(_argv[0])
	if _del == 1; 1
	else; "Couldn't delete old directory"
}

OnShellInstallFailure //Installing a shell that is set as FLELE only fails
{
	void OnEmptyTempFolder
	/* Possible error types:
	can't copy
	can't rename to a zip## folder with same name may already exist
	can't extract: %(_i)
	can't find install.txt
	can't find name/directory in install.txt
	can't change to the name specified in install.txt## folder with same name may already exist
	can't un-nest the directory## a folder with the target name may already exist
	*/
	InstalledShellName = "" //Prevents it from saying the 'installed shell' dialogue
	_error = REPLACE(reference0,"##",",")
	
	"\0\b[0]"
	--
	if ISFUNC("OnCustom_ActionSurfaces") && CustomFuncs[0] == 1; "\![embed,OnCustom_ActionSurfaces,Error]"
	else; "\s[6]"
	--
	if language == "Placeholder" //TRANSLATORS: If a FLELE shell fails to install with FLUX's workaround, this is the error message. I'm not worried about translating the content of the error messages (the list up there is... not up to date), plus if people are contacting me as the message directs them to do, I need to be able to see what the error is. _error contains the error message
	{
		
	}
	elseif language == "Español"
	{
		"[No se ha podido instalar este Shell.\w8\w8 El error es '%(_error)'.\w8\w8 Por favor pongase en contacto con \_a[https://zichqec.github.io/s-the-skeleton/]Zichqec\_a para más asistencia.]"
	}
	elseif language == "Deutsch"
	{
		"[Diese Shell konnte nicht installiert werden.\w8\w8 Der aufgetretene Fehler ist '%(_error)'.\w8\w8 Bitte kontaktiere \_a[https://ukagaka.zichqec.com/]Zichqec\_a für Hilfe.]"
	}
	elseif language == "Русский"
	{
		"[Не удалось установить этот внешний вид.\w8\w8 Вот ошибка: '%(_error)'.\w8\w8 Пожалуйста, сообщите \_a[https://ukagaka.zichqec.com/]Zichqec\_a за помощь.]" 
	}
	elseif language == "Français"
	{
		"[Impossible d'installer ce shell.\w8\w8 L'erreur renvoyée est '%(_error)'.\w8\w8 Merci de contacter \_a[https://ukagaka.zichqec.com/]Zichqec\_a pour de toute assistance.]"
	}
	elseif language == "Polski"
	{
		"[Nie można zainstalować tej skorupy. Błąd to: '%(_error)'. Prosimy o kontakt z \a[https://ukagaka.zichqec.com/]Zichqec\a w celu uzyskania pomocy.]"
	}
	else //English
	{
		"[Could not install this shell.\w8\w8 The error returned is '%(_error)'.\w8\w8 Please contact \_a[https://ukagaka.zichqec.com/]Zichqec\_a for assistance.]"
	}
}

OnUpdatedataCreating //Creating an updates2.dau
{
	"\0\b[0]"
	--
	if ISFUNC("OnCustom_ActionSurfaces") && CustomFuncs[0] == 1; "\![embed,OnCustom_ActionSurfaces,Action]"
	else; "\s[6]"
	--
	if language == "Placeholder" //TRANSLATORS: Creating an updates2.dau file
	{
		
	}
	elseif language == "Español"
	{
		"[Creando archivo de actualización...]\e"
	}
	elseif language == "Deutsch"
	{
		"[Update-Datei wird erstellt...]\e"
	}
	elseif language == "Русский"
	{
		"[Создаю файл обновлении...]\e"
	}
	elseif language == "Français"
	{
		"[Creation d'un fichier de mise à jour...]\e"
	}
	elseif language == "Polski"
	{
		"[Tworzenie pliku aktualizacji...]\e"
	}
	else //English
	{
		"[Creating an update file...]\e"
	}
}

OnUpdatedataCreated //Finished creating
{
	"\0\b[0]"
	--
	if ISFUNC("OnCustom_ActionSurfaces") && CustomFuncs[0] == 1; "\![embed,OnCustom_ActionSurfaces,Action]"
	else; "\s[6]"
	--
	if language == "Placeholder" //TRANSLATORS: Finished creating an updates2.dau file
	{
		
	}
	elseif language == "Español"
	{
		"[Creación de archivo updates2.dau completada.]\e"
	}
	elseif language == "Deutsch"
	{
		"[Updates2.dau wurde erfolgreich erstellt.]\e"
	}
	elseif language == "Русский"
	{
		"[Создал updates2.dau.]\e"
	}
	elseif language == "Français"
	{
		"[Creation du updates2.dau finie.]\e"
	}
	elseif language == "Polski"
	{
		"[Zakończono tworzenie pliku updates2.dau.]\e"
	}
	else //English
	{
		"[Finished creating updates2.dau.]\e"
	}
}

//reference0 is the name of what you're making a nar for, reference2 is what you're making (balloon/ghost/etc)
OnNarCreating //Creating a .nar
{
	"\0\b[0]"
	--
	if ISFUNC("OnCustom_ActionSurfaces") && CustomFuncs[0] == 1; "\![embed,OnCustom_ActionSurfaces,Action]"
	else; "\s[6]"
	--
	if language == "Placeholder" //TRANSLATORS: Creating a .nar file
	{
		
	}
	elseif language == "Español"
	{
		"[Creando archivo .nar...]\e"
	}
	elseif language == "Deutsch"
	{
		"[.nar wird erstellt...]\e"
	}
	elseif language == "Русский"
	{
		"[Создаю .nar...]\e"
	}
	elseif language == "Français"
	{
		"[Création d'un .nar...]\e"
	}
	elseif language == "Polski"
	{
		"[Tworzenie pliku .nar...]\e"
	}
	else //English
	{
		"[Creating a .nar...]\e"
	}
}

//reference0 is the name of what you're making a nar for, reference2 is what you're making (balloon/ghost/etc)
OnNarCreated //Finished creating
{
	"\0\b[0]"
	--
	if ISFUNC("OnCustom_ActionSurfaces") && CustomFuncs[0] == 1; "\![embed,OnCustom_ActionSurfaces,Action]"
	else; "\s[6]"
	--
	if language == "Placeholder" //TRANSLATORS: Finished creating a .nar. The anchor will open the folder where the .nar was saved
	{
		
	}
	elseif language == "Español"
	{
		"[Creación de \_a[OnNarLocation,%(reference1)]%(reference0)\_a completada.]\e"
	}
	elseif language == "Deutsch"
	{
		"[\_a[OnNarLocation,%(reference1)]%(reference0)\_a wurde erfolgreich erstellt.]\e"
	}
	elseif language == "Русский"
	{
		"[Создал \_a[OnNarLocation,%(reference1)]%(reference0)\_a.]\e"
	}
	elseif language == "Français"
	{
		"[Création de \_a[OnNarLocation,%(reference1)]%(reference0)\_a finie.]\e"
	}
	elseif language == "Polski"
	{
		"[Zakończono tworzenie \_a[OnNarLocation,%(reference1)]%(reference0)\_a.]\e"
	}
	else //English
	{
		"[Finished creating \_a[OnNarLocation,%(reference1)]%(reference0)\_a.]\e"
	}
}

//When you click on the anchor in the OnNarCreated dialogue, this function will open the folder you created the .nar in
OnNarLocation
{
	_path = SPLITPATH(reference0)[0] + SPLITPATH(reference0)[1]
	
	"\C\![open,file,%(_path)]"
}

//----Uninstalling----

//Bringing up the uninstall option
OnVanishSelecting
{
	"\0\b[0]"
	--
	if ISFUNC("OnCustom_ActionSurfaces") && CustomFuncs[0] == 1; "\![embed,OnCustom_ActionSurfaces,Action]"
	else; "\s[6]"
	--
	if language == "Placeholder" //TRANSLATORS: The user has brought up the uninstall option
	{
		
	}
	elseif language == "Español"
	{
		"[¿Seguro qué quieres desinstalar el reproductor FLUX y todos sus Shells instalados?]\e"
	}
	elseif language == "Deutsch"
	{
		"[Bist du sicher, dass du FLUX-Player und alle Shells, die du installiert hast, deinstallieren möchtest?]\e"
	}
	elseif language == "Русский"
	{
		"[Ты уверен_а, что хочешь удалить плеер FLUX и всех твоих внешних видов?]\e"
	}
	elseif language == "Français"
	{
		"[Désinstallation de FLUX...]\n\n\w8\w8\s[0][Passe une bonne journée.]"
	}
	elseif language == "Polski"
	{
		"[Czy na pewno chcesz odinstalować FLUX player i wszystkie zainstalowane przez Ciebie skorupy?]\e"
	}
	else //English
	{
		"[Are you sure you want to uninstall FLUX player and all the shells you have installed?]\e"
	}
}

//Deciding to uninstall
OnVanishSelected
{
	"\0\b[0]"
	--
	if ISFUNC("OnCustom_ActionSurfaces") && CustomFuncs[0] == 1; "\![embed,OnCustom_ActionSurfaces,Action]"
	else; "\s[6]"
	--
	if language == "Placeholder" //TRANSLATORS: The user has decided to uninstall. Added some extra wait time here in case they change their minds or clicked by accident
	{
		
	}
	elseif language == "Español"
	{
		"[Desinstalando FLUX...]\n\n\w8\w8\s[0][Que pases un buen día.]"
	}
	elseif language == "Deutsch"
	{
		"[FLUX wird deinstalliert...]\n\n\w8\w8\w8\s[0][Mach's gut.]"
	}
	elseif language == "Русский"
	{
		"[Удалает FLUX...]\n\n\w8\w8\w8\s[0][Хорошего дня.]"
	}
	elseif language == "Français"
	{
		"[Désinstallation de FLUX...]\n\n\w8\w8\s[0][Passe une bonne journée.]"
	}
	elseif language == "Polski"
	{
		"[Odinstalowywanie FLUX...]\n\n\w8\w8\s[0][Życzę miłego dnia.]"
	}
	else //English
	{
		"[Uninstalling FLUX...]\n\n\w8\w8\w8\s[0][Have a nice day.]"
	}
	--
	"\_w[3000]"
}

//When another ghost has been uninstalled and it switches to this ghost - Also happens if this ghost is open when another is uninstalled
//reference0 is the name of the uninstalled ghost
OnVanished
{
	if ISFUNC("OnCustom_OnVanished") && CustomFuncs[0] == 1
	{
		BootVars
		"%(OnNotifySongInfo)%(OnDiscordPluginBoot)\![get,property,OnShellAuthor,currentghost.shelllist.current.craftmanw,currentghost.shelllist.current.craftman,currentghost.shelllist.current.craftmanurl]"
		--
		if ISFUNC("OnCustom_trayicon"); OnCustom_trayicon
		else; "\![set,tasktrayicon,flux.ico]"
		--
		EVAL("OnCustom_OnVanished('boot')")
	}
}

OnOtherGhostVanished
{
	if ISFUNC("OnCustom_OnVanished") && CustomFuncs[0] == 1; OnCustom_OnVanished
	else
	{
		if BalloonCheck; "\C"
		--
		"\![this-is-just-to-stop-it-from-running-the-boot-dialogue-please-let-this-work]"
	}
}

//----Mail checking----

//reference2 is the email address it's checking? Wiki says mail server.
OnBIFFBegin
{
	"\0\b[0]"
	--
	if ISFUNC("OnCustom_ActionSurfaces") && CustomFuncs[0] == 1; "\![embed,OnCustom_ActionSurfaces,Action]"
	else; "\s[6]"
	--
	if language == "Placeholder" //TRANSLATORS: Starting an email check
	{
		
	}
	elseif language == "Español"
	{
		"[Buscando correos nuevos...]\e"
	}
	elseif language == "Deutsch"
	{
		"[Posteingang wird auf neue E-Mails überprüft...]\e"
	}
	elseif language == "Русский"
	{
		"[Проверяет почту...]\e"
	}
	elseif language == "Français"
	{
		"[Vérification des emails...]\e"
	}
	elseif language == "Polski"
	{
		"[Sprawdzanie wiadomości e-mail...]\e"
	}
	else //English
	{
		"[Checking for emails...]\e"
	}
}

//reference0 is the number of emails found
OnBIFFComplete
{
	headers = ""
	if reference7 != "" && reference0 < 100
	{
		headers = SPLIT(reference.raw[7],C_BYTE1)
	}
	--
	"\0\b[0]"
	--
	if ISFUNC("OnCustom_ActionSurfaces") && CustomFuncs[0] == 1; "\![embed,OnCustom_ActionSurfaces,Action]"
	else; "\s[6]"
	--
	if language == "Placeholder" //TRANSLATORS: Result of checking emails, reference0 is the number of emails. It will only offer to show headers if headers are on and there are less than 100 of them
	{
		
	}
	elseif language == "Español"
	{
		_s = ""; if reference0 != 1; _s = "s" //Plural check, adds an s if the number of emails is not 1
		
		if reference0 == 0 //No new emails
		{
			"[No hay correo nuevo.]\e"
		}
		else //There are new emails
		{
			"[Hay %(reference0) correo%(_s) nuevo%(_s).]"
			--
			if headers != "" //If there are headers
			{
				"\n\n\w8\w8[¿Quieres ver el encabezado?]"
				--
				"\n\n\![*]\q[Sí,OnSeeHeaders]  \![*]\q[No,OnCancel]"
			}
			--
			"\e"
		}
	}
	elseif language == "Deutsch"
	{
		_s = ""; if reference0 != 1; _s = "s" //Plural check, adds an s if the number of emails is not 1
		_e = ""; if reference0 != 1; _e = "e"
		_pl = ""
		if reference0 == 1; _pl = "den"
		else; _pl = "die" 
		
		if reference0 == 0 //No new emails
		{
			"[Es wurden keine neuen E-Mails gefunden.]\e"
		}
		else //There are new emails
		{
			"[Du hast %(reference0) neue E-Mail%(_s).]"
			--
			if headers != "" //If there are headers
			{
				"\n\n\w8\w8[Möchtest du %(_pl) Betreff%(_e) sehen?]"
				--
				"\n\n\![*]\q[Ja,OnSeeHeaders]  \![*]\q[Nein,OnCancel]"
			}
			--
			"\e"
		}
	}
	elseif language == "Русский"
	{
		_и = "а"; if reference0 != 1; _и = "и"; _новые = "новая"; if reference0 != 1; _новые = "новые"; _почти = "электронная почта"; if reference0 != 1; _почти = "электронные почти"
		
		if reference0 == 0 //No new emails
		{
			"[Ничего нового.]\e"
		}
		else //There are new emails
		{
			"[%(reference0) %(_новые) %(_почти).]"
			--
			if headers != "" //If there are headers
			{
				"\n\n\w8\w8[Хочешь поглядеть на заголовк%(_и)?]"
				--
				"\n\n\![*]\q[Да,OnSeeHeaders]  \![*]\q[Нет,OnCancel]"
			}
			--
			"\e"
		}
	}
	elseif language == "Français"
	{
		_s = ""; if reference0 != 1; _s = "s" //Plural check, adds an s if the number of emails is not 1
		
		if reference0 == 0 //No new emails
		{
			"[Pas de nouveaux emails.]\e"
		}
		else //There are new emails
		{
			"[%(reference0) nouveaux email%(_s).]"
			--
			if reference7 != "" && reference0 < 100 //If it's less than 100 emails and there are headers
			{
				"\n\n\w8\w8[Veux-tu voir les en-têtes ?]"
				--
				"\n\n\![*]\q[Oui,OnSeeHeaders]  \![*]\q[Non,OnCancel]"
			}
			--
			"\e"
		}
	}
	elseif language == "Polski"
	{
		_s = ""; if reference0 != 1; _s = "i" //Plural check, adds an s if the number of emails is not 1
		_c = ""; if reference0 != 1; _c = "ch"
		_ki = ""; if reference0 != 1; _ki = "ek"
		else; _ki = "ki"
		
		if reference0 == 0 //No new emails
		{
			"[Brak nowych e-maili.]\e"
		}
		else //There are new emails
		{
			"[%(reference0) nowy%(_c) email%(_s).]"
			--
			if headers != "" //If there are headers
			{
				"\n\n\w8\w8[Czy chcesz zobaczyć nagłów%(_ki)?]"
				--
				"\n\n\![*]\q[Tak,OnSeeHeaders]  \![*]\q[Nie,OnCancel]"
			}
			--
			"\e"
		}
	}
	else //English
	{
		_s = ""; if reference0 != 1; _s = "s" //Plural check, adds an s if the number of emails is not 1
		
		if reference0 == 0 //No new emails
		{
			"[No new emails.]\e"
		}
		else //There are new emails
		{
			"[%(reference0) new email%(_s).]"
			--
			if headers != "" //If there are headers
			{
				"\n\n\w8\w8[Do you want to see the header%(_s)?]"
				--
				"\n\n\![*]\q[Yes,OnSeeHeaders]  \![*]\q[No,OnCancel]"
			}
			--
			"\e"
		}
	}
}

//Displaying the headers. No need to touch this other than changing the surface, or if you want to make the buttons different or something. Reference0 is the list of headers
OnSeeHeaders
{
	_display = ""
	foreach headers; _header
	{
		_display += "\![*]"
		_display += SHIORI3FW.EscapeAllTags(_header)
		_display += "\n\n"
	}
	
	"\0\b[4]"
	--
	if ISFUNC("OnCustom_ActionSurfaces") && CustomFuncs[0] == 1; "\![embed,OnCustom_ActionSurfaces,Action]"
	else; "\s[6]"
	--
	"\_q%(_display)\*"
	--
	if language == "Placeholder" //TRANSLATORS: This is just the button for when you're done looking at email headers
	{
		
	}
	elseif language == "Español"
	{
		"\n\n\![*]\q[Cerrar,OnCancel]\e"
	}
	elseif language == "Deutsch"
	{
		"\n\n\![*]\q[Schließen,OnCancel]\e"
	}
	elseif language == "Русский"
	{
		"\n\n\![*]\q[Закрыть,OnCancel]\e"
	}
	elseif language == "Français"
	{
		"\n\n\![*]\q[Fermer,OnCancel]\e"
	}
	elseif language == "Polski"
	{
		"\n\n\![*]\q[Zamknij,OnCancel]\e"
	}
	else //English
	{
		"\n\n\![*]\q[Close,OnCancel]\e"
	}
	--
	ERASEVAR("headers") //This erases the variable so you're not storing all those headers and bloating your save. Also, privacy reasons.
}

//Email checking failed
//reference0 is the error returned
OnBIFFFailure
{
	"\0\b[0]"
	--
	if ISFUNC("OnCustom_ActionSurfaces") && CustomFuncs[0] == 1; "\![embed,OnCustom_ActionSurfaces,Error]"
	else; "\s[6]"
	--
	if language == "Placeholder" //TRANSLATORS: If the email checking fails
	{
		
	}
	elseif language == "Español"
	{
		if reference0 == "timeout" //If the connection times out
		{
			"[El tiempo de conexión se ha agotado.]\e"
		}
		elseif reference0 == "kick" //if the ghost can't get into the account. Gmail requires an app specific password to get in
		{
			"[No se ha podido acceder a la cuenta.]\e"
		}
		elseif reference0 == "defect" //If info in the POP menu is wrong
		{
			"[Los ajustes POP no son correctos.]"
			--
			"\![Abrir,configurationdialog,biff]\e"
		}
		elseif reference0 == "artificial" //As far as I can tell, artificial is if the user double clicks on the balloon to stop it
		{
			"[Comprobación de correo cancelada.]\e"
		}
		else //Some other kind of error.
		{
			"[No se ha podido comprobar el correo: '%(reference0)'.]\e"
		}
	}
	elseif language == "Deutsch"
	{
		if reference0 == "timeout" //If the connection times out
		{
			"[Es gab eine Zeitüberschreitung beim Verbindungsversuch.]\e"
		}
		elseif reference0 == "kick" //if the ghost can't get into the account. Gmail requires an app specific password to get in
		{
			"[Es kann nicht auf den Account zugegriffen werden.]\e"
		}
		elseif reference0 == "defect" //If info in the POP menu is wrong
		{
			"[Die POP Einstellungen sind nicht korrekt.]"
			--
			"\![open,configurationdialog,biff]\e"
		}
		elseif reference0 == "artificial" //As far as I can tell, artificial is if the user double clicks on the balloon to stop it
		{
			"[Die Suche nach E-Mails wurde abgebrochen.]\e"
		}
		else //Some other kind of error.
		{
			"[Die Suche nach E-Mails ist fehlgeschlagen: '%(reference0)'.]\e"
		}
	}
	elseif language == "Русский"
	{
		if reference0 == "timeout" //If the connection times out
		{
			"[Связь истекшим временем ожидания.]\e"
		}
		elseif reference0 == "kick" //if the ghost can't get into the account. Gmail requires an app specific password to get in
		{
			"[Я не могу войти в аккаунт.]\e"
		}
		elseif reference0 == "defect" //If info in the POP menu is wrong
		{
			"[Настройки POP неправильная.]"
			--
			"\![open,configurationdialog,biff]\e"
		}
		elseif reference0 == "artificial" //As far as I can tell, artificial is if the user double clicks on the balloon to stop it
		{
			"[Отметил_а проверяние.]\e"
		}
		else //Some other kind of error.
		{
			"[Не удалось проверять, потому что: '%(reference0)'.]\e"
		}
	}
	elseif language == "Français" 
	{
		if reference0 == "timeout" //If the connection times out
		{
			"[La connexion a expirée.]\e"
		}
		elseif reference0 == "kick" //if the ghost can't get into the account. Gmail requires an app specific password to get in
		{
			"[Impossible de se connecter au compte.]\e"
		}
		elseif reference0 == "defect" //If info in the POP menu is wrong
		{
			"[Les paramètres POP ne sont pas corrects.]"
			--
			"\![open,configurationdialog,biff]\e"
		}
		elseif reference0 == "artificial" //As far as I can tell, artificial is if the user double clicks on the balloon to stop it
		{
			"[Vérification des emails annulée.]\e"
		}
		else //Some other kind of error.
		{
			"[Echec de la vérification des emails: '%(reference0)'.]\e"
		}
	}
	elseif language == "Polski"
	{
		if reference0 == "timeout" //If the connection times out
		{
			"[Połączenie zostało przerwane..]\e"
		}
		elseif reference0 == "kick" //if the ghost can't get into the account. Gmail requires an app specific password to get in
		{
			"[Nie można dostać się na konto.]\e"
		}
		elseif reference0 == "defect" //If info in the POP menu is wrong
		{
			"[Ustawienia POP są nieprawidłowe.]"
			--
			"\![open,configurationdialog,biff]\e"
		}
		elseif reference0 == "artificial" //As far as I can tell, artificial is if the user double clicks on the balloon to stop it
		{
			"[Anulowano sprawdzanie poczty elektronicznej.]\e"
		}
		else //Some other kind of error.
		{
			"[Sprawdzanie poczty elektronicznej nie powiodło się: '%(reference0)'.]\e"
		}
	}
	else //English
	{
		if reference0 == "timeout" //If the connection times out
		{
			"[The connection timed out.]\e"
		}
		elseif reference0 == "kick" //if the ghost can't get into the account. Gmail requires an app specific password to get in
		{
			"[Cannot get into the account.]\e"
		}
		elseif reference0 == "defect" //If info in the POP menu is wrong
		{
			"[The POP settings are not correct.]"
			--
			"\![open,configurationdialog,biff]\e"
		}
		elseif reference0 == "artificial" //As far as I can tell, artificial is if the user double clicks on the balloon to stop it
		{
			"[Cancelled email check.]\e"
		}
		else //Some other kind of error.
		{
			"[Email check failed: '%(reference0)'.]\e"
		}
	}
}

//----Network update---

OnStartUpdates
{
	_cmd = ""
	if AutoUpdates[3] == 1; _cmd += "ghost+"
	if AutoUpdates[4] == 1; _cmd += "shell+"
	if AutoUpdates[5] == 1; _cmd += "balloon+"
	_cmd = ERASE(_cmd,(STRLEN(_cmd) - 1),1)
	"\![update,%(_cmd)]"
}

//When the ghost finishes checking for updates
//reference0 is 'none' if there are no new files, and 'changed' if there are new files. reference1 is a list of the changed files, separated by commas
OnUpdateCheckComplete
{
	AutoUpdates[1] = 1 //Sets it so it won't check again until at least midnight
	if reference0 == "none" //If there are no new files
	{
		if reference3 == "ghost"; AutoUpdates[3] = 0
		elseif reference3 == "shell"; AutoUpdates[4] = 0
		elseif reference3 == "balloon"; AutoUpdates[5] = 0
	}
	else
	{
		if reference3 == "ghost"; AutoUpdates[3] = 1
		elseif reference3 == "shell"; AutoUpdates[4] = 1
		elseif reference3 == "balloon"; AutoUpdates[5] = 1
	}
	--
	if reference3 == "ghost"; "\![update,shell,checkonly]"
	elseif reference3 == "shell"; "\![update,balloon,checkonly]"
	else; "\e Update Check Complete"
}

OnUpdateCheckFailure
{
	AutoUpdates[1] = 1 //Sets it so it won't check again until at least midnight
	if reference3 == "ghost"; AutoUpdates[3] = 0
	elseif reference3 == "shell"; AutoUpdates[4] = 0
	elseif reference3 == "balloon"; AutoUpdates[5] = 0
	--
	if reference3 == "ghost"; "\![update,shell,checkonly]"
	elseif reference3 == "shell"; "\![update,balloon,checkonly]"
	else; "\e Update Check Complete"
}


//Starting to actually update
OnUpdateBegin
{
	"\0\b[0]"
	--
	if ISFUNC("OnCustom_ActionSurfaces") && CustomFuncs[0] == 1; "\![embed,OnCustom_ActionSurfaces,Action]"
	else; "\s[6]"
	--
	if language == "Placeholder" //TRANSLATORS: Beginning an update
	{
		
	}
	elseif language == "Español"
	{
		"[Comenzando actualización...]\w8\e"
	}
	elseif language == "Deutsch"
	{
		"[Updatevorgang wird gestartet...]\w8\e"
	}
	elseif language == "Русский"
	{
		"[Начинает обновления...]\w8\e"
	}
	elseif language == "Français"
	{
		"\0\b[0]\s[6][Démarrage de la mise à jour...]\w8\e"
	}
	elseif language == "Polski"
	{
		"[Zaczynam aktualizacjie...]\w8\e"
	}
	else //English
	{
		"[Beginning update...]\w8\e"
	}
}

//reference0 is the number of new files, starting from 0
OnUpdateReady
{
	reference0++ //Number of files starts from 0, so this displays the correct amount
	
	"\0\b[0]"
	--
	if ISFUNC("OnCustom_ActionSurfaces") && CustomFuncs[0] == 1; "\![embed,OnCustom_ActionSurfaces,Action]"
	else; "\s[6]"
	--
	if language == "Placeholder" //TRANSLATORS: If update files were found. reference0 is the number of files
	{
		
	}
	elseif language == "Español"
	{
		_s = ""; if reference0 != 1; _s = "s"; //plural checks, adds an s and changes is to are if there's more than 1 file

		"[Hay %(reference0) archivo%(_s) nuevo%(_s).]"
	}
	elseif language == "Deutsch"
	{
		_s = ""; if reference0 != 1; _s = "en" //plural checks, adds an s and changes is to are if there's more than 1 file

		"[Es gibt %(reference0) neue Datei%(_s).]"
	}
	elseif language == "Русский"
	{
		_новые = "новый"; _файли = "файл"; if reference0 != 1; {_новые = "новые"; _файли = "файли"}

		"[Есть %(reference0) %(_новые) %(_файли).]"
	}
	elseif language == "Français"
	{
		_s = ""; _is = ""; if reference0 != 1; {_s = "s"; _is = "x"} //plural checks, adds an s and changes is to are if there's more than 1 file

		"[Il y a %(reference0) nouveau%(_is) fichier%(_s).]"
	}
	elseif language == "Polski"
	{
		_s = ""; if reference0 != 1; _s = "ów"; //plural checks, adds an s and changes is to are if there's more than 1 file

		"[Znalezłem %(reference0) nowych plik%(_s).]"
	}
	else //English
	{
		_s = ""; _is = "is"; if reference0 != 1; {_s = "s"; _is = "are"} //plural checks, adds an s and changes is to are if there's more than 1 file

		"[There %(_is) %(reference0) new file%(_s).]"
	}
	--
	if ISFUNC("OnCustom_ActionSurfaces") && CustomFuncs[0] == 1; "\w8\w8\![embed,OnCustom_ActionSurfaces,Action]\e"
	else; "\w8\w8\s[6]\e"
}

//reference0 is 'none' if there were no new files to update with, reference1 is a list of new file names, separated by commas
OnUpdateComplete
{
	UpdateVars
	AutoUpdates[1] = 0
	
	"\0\b[0]"
	--
	if ISFUNC("OnCustom_ActionSurfaces") && CustomFuncs[0] == 1; "\![embed,OnCustom_ActionSurfaces,Action]"
	else; "\s[6]"
	--
	if language == "Placeholder" //TRANSLATORS: If there are no new files, or an update completed successfully
	{
		
	}
	elseif language == "Español"
	{
		if reference0 == "none"
		{
			"[FLUX ya está actualizado.\w8\w8 Para buscar actualizaciones de apariencias,\w4 pulse la opción actualizar apariencia en el menú configuración.]\e"
		}
		else
		{
			"[Actualización de FLUX completada.\w8\w8 ¿Abrir historial de cambios?]"
			--
			"\n\n\![*]\q[Sí,OnChangeLog]\n\![*]\q[No,OnCancel]\e"
		}
	}
	elseif language == "Deutsch"
	{
		if reference0 == "none"
		{
			"[FLUX ist auf dem neuesten Stand.\w8\w8 Um nach Shell-Updates zu suchen\w4 klicke die 'Update Shell' Option in den Einstellungen.]\e"
		}
		else
		{
			"[FLUX-Update wurde fertiggestellt.\w8\w8 Soll das Änderungsprotokoll geöffnet werden?]"
			--
			"\n\n\![*]\q[Ja,OnChangeLog]\n\![*]\q[Nein,OnCancel]\e"
		}
	}
	elseif language == "Русский"
	{
		if reference0 == "none"
		{
			"[FLUX на последняя версия.\w8\w8 Чтобы проверять обновление вида,\w4 нажмите на настройка в меню конфигурации.]\e"
		}
		else
		{
			//"[Обновления FLUX закончено.]" //готов?
			"[Обновление FLUX успешно.\w8\w8 Открыть лог изменение?]"
			--
			"\n\n\![*]\q[Да,OnChangeLog]\n\![*]\q[Нет,OnCancel]\e"
		}
	}
	elseif language == "Français"
	{
		if reference0 == "none"
		{
			"[FLUX est à jour.\w8\w8 Pour vérifier les mises à jour du shell,\w4 clique l'option de mise à jour du shell du menu config.]\e"
		}
		else
		{
			"[Mise à jour de FLUX complète.\w8\w8 Ouvrir le changelog ?]"
			--
			"\n\n\![*]\q[Oui,OnChangeLog]\n\![*]\q[Non,OnCancel]\e"
		}
	}
	elseif language == "Polski"
	{
		if reference0 == "none"
		{
			"[FLUX jest aktualny.\w8\w8 Aby sprawdzić dostępność aktualizacji skorupy,\w4 kliknij opcję aktualizacji skorupy w ustawieniach.]\e"
		}
		else
		{
			//"[FLUX został zaktualizowany]"
			"[FLUX został zaktualizowany.\w8\w8 Czy chcesz zobaczyć liste zmian??]"
			--
			"\n\n\![*]\q[Tak,OnChangeLog]\n\![*]\q[Nie,OnCancel]\e"
		}
	}
	else //English - TODO NOTE TO SELF MAKE SURE THIS SAYS CONFIG MENU
	{
		if reference0 == "none"
		{
			"[FLUX is up to date.\w8\w8 To check for shell updates,\w4 click the update shell option in the config menu.]\e"
		}
		else
		{
			"[FLUX Update complete.\w8\w8 Open the changelog?]"
			--
			"\n\n\![*]\q[Yes,OnChangeLog]\n\![*]\q[No,OnCancel]\e"
		}
	}
}

OnChangeLog
{
	"\j[""https://ukagaka.zichqec.com/ghost/flux#version_history""]\e"
}

//I've put this here so it's easier to remember to update the version number while you're updating the changelog. This will display on the ghost's menu. I made it an envelope so you can have it be the same across multiple menus for multiple modes, if you want.
ghostver
{
	"1.2.2"
}

//reference0 is the reason the update failed
OnUpdateFailure //If the update fails
{
	_currentfile = SPLITPATH(reference1)[2] + SPLITPATH(reference1)[3]
	
	"\0\b[0]"
	--
	if ISFUNC("OnCustom_ActionSurfaces") && CustomFuncs[0] == 1; "\![embed,OnCustom_ActionSurfaces,Error]"
	else; "\s[6]"
	--
	if language == "Placeholder" //TRANSLATORS: If the update fails for some reason. For the md5 miss one, _currentfile is the name of the file that had the error
	{
		
	}
	elseif language == "Español"
	{
		if reference0 == "timeout" //If it timed out
		{
			"[El tiempo de conexión se ha agotado.]"
		}
		elseif reference0 == "md5 miss" //If the update files have not been uploaded correctly and don't match the updates2.dau
		{
			"[Los valores MD5 no concuerdan con '%(_currentfile)'.\w8\w8 Debes contactar con \_a[https://ukagaka.zichqec.com/]Zichqec\_a para arreglar el problema.]"
		}
		elseif reference0 == "artificial" //If the user cancels the update by double clicking the balloon
		{
			"[Actualización cancelada.]"
		}
		else //Any other errors
		{
			"[No se ha podido actualizar: '%(reference0)'.]"
		}
	}
	elseif language == "Deutsch"
	{
		if reference0 == "timeout" //If it timed out
		{
			"[Es gab eine Zeitüberschreitung beim Verbindungsversuch.]"
		}
		elseif reference0 == "md5 miss" //If the update files have not been uploaded correctly and don't match the updates2.dau
		{	
			"[Die MD5-Werte in '%(_currentfile)' stimmen nicht überein.\w8\w8 Bitte kontaktiere \_a[https://ukagaka.zichqec.com/]Zichqec\_a um dieses Problem zu lösen.]"
		}
		elseif reference0 == "artificial" //If the user cancels the update by double clicking the balloon
		{
			"[Update wurde abgebrochen.]"
		}
		else //Any other errors
		{
			"[Update konnte nicht durchgeführt werden: '%(reference0)'.]"
		}
	}
	elseif language == "Русский"
	{
		if reference0 == "timeout" //If it timed out
		{
			"[Связь истекшим временем ожидания.]"
		}
		elseif reference0 == "md5 miss" //If the update files have not been uploaded correctly and don't match the updates2.dau
		{
			"[Значение MD5 '%(_currentfile)' не согласны.\w8\w8 Надо сообщить \_a[https://ukagaka.zichqec.com/]Zichqec\_a, чтобы исправить эту ошибку.]"
		}
		elseif reference0 == "artificial" //If the user cancels the update by double clicking the balloon
		{
			"[Отметил_а обновление.]" //обновления?
		}
		else //Any other errors
		{
			"[Ошибок был: '%(reference0)'.]"
		}	
	}
	elseif language == "Français"
	{
		if reference0 == "timeout" //If it timed out
		{
			"[La connexion a expirée.]"
		}
		elseif reference0 == "md5 miss" //If the update files have not been uploaded correctly and don't match the updates2.dau
		{
			//TODO FRENCH
			"[The MD5 values don't match on '%(_currentfile)'.\w8\w8 You should contact \_a[https://ukagaka.zichqec.com/]Zichqec\_a to fix this issue.]"
		}
		elseif reference0 == "artificial" //If the user cancels the update by double clicking the balloon
		{
			"[Mise à jour annulée.]"
		}
		else //Any other errors
		{
			"[Impossible de mettre à jour : '%(reference0)'.]"
		}
	}
	elseif language == "Polski"
	{
		if reference0 == "timeout" //If it timed out
		{
			"[Połączenie zostało przerwane..]"
		}
		elseif reference0 == "md5 miss" //If the update files have not been uploaded correctly and don't match the updates2.dau
		{
			//TODO POLISH
			"[The MD5 values don't match on '%(_currentfile)'.\w8\w8 You should contact \_a[https://ukagaka.zichqec.com/]Zichqec\_a to fix this issue.]"
		}
		elseif reference0 == "artificial" //If the user cancels the update by double clicking the balloon
		{
			"[Aktualizacja anulowana.]"
		}
		else //Any other errors
		{
			"[Nie można było zaktualiować: '%(reference0)'.]"
		}	
	}
	else //English
	{
		if reference0 == "timeout" //If it timed out
		{
			"[The connection has timed out.]"
		}
		elseif reference0 == "md5 miss" //If the update files have not been uploaded correctly and don't match the updates2.dau
		{
			"[The MD5 values don't match on '%(_currentfile)'.\w8\w8 You should contact \_a[https://ukagaka.zichqec.com/]Zichqec\_a to fix this issue.]"
		}
		elseif reference0 == "artificial" //If the user cancels the update by double clicking the balloon
		{
			"[Update canceled.]"
		}
		else //Any other errors
		{
			"[Couldn't update: '%(reference0)'.]"
		}
	}
}

OnUpdateOtherBegin
{
	_target = ""
	
	"\0\b[0]"
	--
	if ISFUNC("OnCustom_ActionSurfaces") && CustomFuncs[0] == 1; "\![embed,OnCustom_ActionSurfaces,Action]"
	else; "\s[6]"
	--
	if language == "Placeholder" //TRANSLATORS: Beginning an update for a shell/balloon. reference3 will have either shell or balloon, depending on what is being updated. You can use _target like Polski does to change the label appropriately
	{
		
	}
	elseif language == "Español"
	{
		"[Comenzando actualización de %(reference3)...]"
	}
	elseif language == "Deutsch"
	{
		"[%(Capitalize(reference3))-Update wird gestartet...]"
	}
	elseif language == "Русский"
	{
		if reference3 == "shell"; _target = "Внешнего Вида"
		elseif reference3 == "balloon"; _target = "Поле с Текстом"
		
		"[Начинает обновление %(_target)...]"
	}
	elseif language == "Français"
	{
		if reference3 == "shell"; _target = "shell"
		elseif reference3 == "balloon"; _target = "ballon"
		
		"[Début de la mise à jour de %(_target)...]"
	}
	elseif language == "Polski"
	{
		if reference3 == "shell"; _target = "skorupy"
		elseif reference3 == "balloon"; _target = "balona"
		
		"[Zaczynam aktualizacje %(_target)...]"
	}
	else //English
	{
		"[Beginning %(reference3) update...]"
	}
	--
	"\w8\e"
}

OnUpdateOtherReady
{
	reference0++ //Number of files starts from 0, so this displays the correct amount
	
	"\0\b[0]"
	--
	if ISFUNC("OnCustom_ActionSurfaces") && CustomFuncs[0] == 1; "\![embed,OnCustom_ActionSurfaces,Action]"
	else; "\s[6]"
	--
	if language == "Placeholder" //TRANSLATORS: If update files were found for a shell/balloon. reference0 is the number of files
	{
		
	}
	elseif language == "Español"
	{
		_s = ""; if reference0 != 1; _s = "s" //plural checks, adds an s and changes 'is' to 'are' if there's more than 1 file

		"[Hay %(reference0) archivo%(_s) nuevo%(_s).]"
	}
	elseif language == "Deutsch"
	{
		_s = ""; if reference0 != 1; _s = "en"

		"[Es gibt %(reference0) neue Datei%(_s).]"
	}
	elseif language == "Русский"
	{
		_новые = "новый"; _файли = "файл"; if reference0 != 1; {_новые = "новые"; _файли = "файли"}

		"[Есть %(reference0) %(_новые) %(_файли).]"
	}
	elseif language == "Français"
	{
		_s = ""; _is = ""; if reference0 != 1; {_s = "s"; _is = "x"} //plural checks, adds an s and changes is to are if there's more than 1 file

		"[Il y a %(reference0) nouveau%(_is) fichier%(_s).]"
	}
	elseif language == "Polski"
	{
		_s = ""; if reference0 != 1; _s = "ów"; //plural checks, adds an s and changes is to are if there's more than 1 file

		"[Znalezłem %(reference0) nowych plik%(_s).]"
	}
	else //English
	{
		_s = ""; _is = "is"; if reference0 != 1; {_s = "s"; _is = "are"} //plural checks, adds an s and changes 'is' to 'are' if there's more than 1 file

		"[There %(_is) %(reference0) new file%(_s).]"
	}
	--
	if ISFUNC("OnCustom_ActionSurfaces") && CustomFuncs[0] == 1; "\w8\w8\![embed,OnCustom_ActionSurfaces,Action]\e"
	else; "\w8\w8\s[6]\e"
}

OnUpdateOtherComplete
{
	UpdateVars
	AutoUpdates[1] = 0
	
	_target = reference3
	_name = ""
	if reference3 == "shell"; _name = nowshell
	elseif reference3 == "balloon"; _name = SHIORI3FW.BalloonName
	
	"\0\b[0]"
	--
	if ISFUNC("OnCustom_ActionSurfaces") && CustomFuncs[0] == 1; "\![embed,OnCustom_ActionSurfaces,Action]"
	else; "\s[6]"
	--
	if reference3 == "shell"; OnGetCustomShellDialogue
	--
	if language == "Placeholder" //TRANSLATORS: If there are no new files, or an update completed successfully
	{
		if reference0 == "none" //If whatever was updated is up to date
		{
			
		}
		else //If an update completed successfully
		{
			
		}
	}
	elseif language == "Español"
	{
		if reference0 == "none"
		{
			"['%(_name)' ya está actualizado.]\e"
		}
		else
		{
			"[%(Capitalize(_target)) ha sido actualizado.]\e"
		}
	}
	elseif language == "Deutsch"
	{
		if reference0 == "none"
		{
			"[%(_target) ist auf dem neuesten Stand.]\e"
		}
		else
		{
			"[%(Capitalize(reference3))-Update wurde fertiggestellt.]\e"
		}
	}
	elseif language == "Русский"
	{
		if reference0 == "none"
		{
			"[Есть последняя версия %(_target).]\e"
		}
		else
		{
			"[обновления %(reference3) готов.]\e"
		}
	}
	elseif language == "Français"
	{
		if reference3 == "shell"; _target = "shell"
		elseif reference3 == "balloon"; _target = "ballon"
		
		if reference0 == "none"
		{
			"['%(_name)' est à jour.]\e"
		}
		else
		{
			"[Mise à jour de %(_target) complète.]\e"
		}
	}
	elseif language == "Polski"
	{
		if reference3 == "shell"; _target = "skorupy"
		elseif reference3 == "balloon"; _target = "balona"
		
		if reference0 == "none"
		{
			"['%(_name)' jest aktualny.]\e"
		}
		else
		{
			"[Aktualizacje %(_target) zakończona.]\e"
		}
	}
	else //English
	{
		if reference0 == "none"
		{
			"['%(_name)' is up to date.]\e"
		}
		else
		{
			"[%(Capitalize(_target)) update complete.]\e"
		}
	}
	
}

OnUpdateOtherFailure
{
	_target = reference3
	_author = shellauthor[0]
	_authorurl = shellauthor[2]
	_currentfile = SPLITPATH(reference1)[2] + SPLITPATH(reference1)[3]
	"\0\b[0]"
	--
	if ISFUNC("OnCustom_ActionSurfaces") && CustomFuncs[0] == 1; "\![embed,OnCustom_ActionSurfaces,Error]"
	else; "\s[6]"
	--
	if language == "Placeholder" //TRANSLATORS: If the shell/balloon update fails for some reason. For the md5 miss one, _currentfile is the name of the file that had the error, _author is the name of the shell/balloon author, and _authorurl is their url which you can put into the anchor. reference3 will be either shell or ghost, depending on what type of update this is. You can use _target like Polski does to set up labels for shell/balloon specifically for your language
	{
		
	}
	elseif language == "Español"
	{
		if reference0 == "timeout"
		{
			"[El tiempo de conexión se ha agotado.]\e"
		}
		elseif reference0 == "md5 miss"
		{
			"[Los valores MD5 no corresponden con '%(_currentfile)'.\w8\w8 Debes contactar con \_a[%(_authorurl)]%(_author)\_a.]\e"
		}
		elseif reference0 == "artificial"
		{
			"[Actualización de %(Capitalize(reference3)) cancelada.]\e"
		}
		else //Any other errors
		{
			"[No se ha podido actualizar %(reference3): '%(reference0)'.]\e"
		}
	}
	elseif language == "Deutsch"
	{
		if reference0 == "timeout" //If it timed out
		{
			"[Es gab eine Zeitüberschreitung beim Verbindungsversuch.]\e"
		}
		elseif reference0 == "md5 miss" //If the update files have not been uploaded correctly and don't match the updates2.dau
		{
			"[Die MD5 Werte stimmen nicht mit jenen in '%(_currentfile)' überein.\w8\w8 Du solltest \_a[%(_authorurl)]%(_author)\_a kontaktieren.]\e"
		}
		elseif reference0 == "artificial" //If the user cancels the update by double clicking the balloon
		{
			"[%(Capitalize(reference3))-Update wurde abgebrochen.]\e"
		}
		else //Any other errors
		{
			"[%(Capitalize(reference3)) konnte nicht geupdatet werden: '%(reference0)'.]\e"
		}
	}
	elseif language == "Русский"
	{
		if reference3 == "shell"; _target = "Внешний Вид"
		elseif reference3 == "balloon"; _target = "Поле с Текстом"
		
		if reference0 == "timeout" //If it timed out
		{
			"[Связь истекшим временем ожидания.]\e"
		}
		elseif reference0 == "md5 miss" //If the update files have not been uploaded correctly and don't match the updates2.dau
		{
			"[Хеш-значении MD5 не согласится друг друга.\w8\w8 Сообщить автором \_a[%(_authorurl)]%(_author)\_a и расскажи нее, что файл '%(_currentfile)' даёт ошибок MD5.]\e"
		}
		elseif reference0 == "artificial" //If the user cancels the update by double clicking the balloon
		{
			"[Отметил_а обновление.]\e" //обновления?
		}
		else //Any other errors
		{
			"[Ошибок был: %(_target) '%(reference0)'.]\e"
		}	
	}
	elseif language == "Français"
	{
		if reference3 == "shell"; _target = "shell"
		elseif reference3 == "balloon"; _target = "ballon"
		
		if reference0 == "timeout" //If it timed out
		{
			"[La connexion a expiré.]\e"
		}
		elseif reference0 == "md5 miss" //If the update files have not been uploaded correctly and don't match the updates2.dau
		{
			"[La valeur MD5 ne correspond pas pour le fichier '%(_currentfile)'.\w8\w8 Tu devrais contacter \_a[%(_authorurl)]%(_author)\_a.]\e"
		}
		elseif reference0 == "artificial" //If the user cancels the update by double clicking the balloon
		{
			"[Mise à jour de %(_target) annulée.]\e"
		}
		else //Any other errors
		{
			"[Mise à jour de %(_target) impossible : '%(reference0)'.]\e"
		}
	}
	elseif language == "Polski"
	{
		if reference3 == "shell"; _target = "skorupy"
		elseif reference3 == "balloon"; _target = "balona"
		
		if reference0 == "timeout" //If it timed out
		{
			"[Połączenie zostało przerwane..]\e"
		}
		elseif reference0 == "md5 miss" //If the update files have not been uploaded correctly and don't match the updates2.dau
		{
			"[Wartości MD5 nie zgadzają się na '%(_currentfile)'.\w8\w8 Powinieneś skontaktować się z \_a[%(_authorurl)]%(_author)\_a i dać im znać.]\e"
		}
		elseif reference0 == "artificial" //If the user cancels the update by double clicking the balloon
		{
			"[Aktualizacja anulowana.]\e"
		}
		else //Any other errors
		{
			"[Nie udało się zaktualiować %(_target): '%(reference0)'.]\e"
		}	
	}
	else //English
	{
		if reference0 == "timeout" //If it timed out
		{
			"[The connection has timed out.]\e"
		}
		elseif reference0 == "md5 miss" //If the update files have not been uploaded correctly and don't match the updates2.dau
		{
			"[The MD5 values don't match on '%(_currentfile)'.\w8\w8 You should contact \_a[%(_authorurl)]%(_author)\_a.]\e"
		}
		elseif reference0 == "artificial" //If the user cancels the update by double clicking the balloon
		{
			"[%(Capitalize(reference3)) update cancelled.]\e"
		}
		else //Any other errors
		{
			"[Couldn't update %(reference3): '%(reference0)'.]\e"
		}
	}
}

//reference0 is the reason it failed
OnHeadlinesenseFailure
{
	"\0\b[0]"
	--
	if ISFUNC("OnCustom_ActionSurfaces") && CustomFuncs[0] == 1; "\![embed,OnCustom_ActionSurfaces,Error]"
	else; "\s[6]"
	--
	if language == "Placeholder" //TRANSLATORS: If there's an error when getting an RSS feed
	{
		
	}
	elseif language == "Español" 
	{
		"[No se han podido actualizar las noticias: '%(reference0)'.]"
	}
	elseif language == "Deutsch"
	{
		"[Feed konnte nicht geupdatet werden: '%(reference0)'.]"
	}
	elseif language == "Русский" 
	{
		"[Не могу обновить новости: '%(reference0)'.]"
	}
	elseif language == "Français"
	{
		"[Impossible de mettre à jour le flux : '%(reference0)'.]"
	}
	elseif language == "Polski" 
	{
		"[Nie można zaktualizować kanału: '%(reference0)'.]"
	}
	else //English
	{
		"[Can't update feed: '%(reference0)'.]"
	}
}

//reference0 is the name of the server it's connecting to, reference1 is the server's time, reference2 is the computer's time, reference3 is the difference (in seconds)
OnSNTPCompare
{
	"\0\b[0]"
	--
	if ISFUNC("OnCustom_ActionSurfaces") && CustomFuncs[0] == 1; "\![embed,OnCustom_ActionSurfaces,Action]"
	else; "\s[6]"
	--
	if language == "Placeholder" //TRANSLATORS: Comparing the time
	{
		
	}
	elseif language == "Español"
	{
		if reference3 == 0
		{
			"[Tu reloj está en hora.]\e"
		}
		else
		{
			"[Tu reloj no está en hora.]\n\n"
			--
			"\_q\![*]\q[Arreglar,OnSNTPExecute]  \![*]\q[No hacer nada,OnCancel]\e" 
		}
	}
	elseif language == "Deutsch"
	{
		if reference3 == 0 //if your clock is already accurate.
		{
			"[Deine Uhr geht richtig.]\e"
		}
		else //if your clock doesn't match
		{
			"[Deine Uhr stimmt nicht überein.]\n\n"
			--
			"\_q\![*]\q[Neue Zeit übernehmen,OnSNTPExecute]  \![*]\q[Alte Zeit beibehalten,OnCancel]\e" 
		}
	}
	elseif language == "Русский"
	{
		if reference3 == 0 //if your clock is already accurate.
		{
			"[Твой часы в порядке.]\e"
		}
		else //if your clock doesn't match
		{
			"[Твой часы сломал.]\n\n"
			--
			"\_q\![*]\q[Починить его,OnSNTPExecute]  \![*]\q[Оставить его,OnCancel]\e" 
		}
	}
	elseif language == "Français"
	{
		if reference3 == 0 //if your clock is already accurate.
		{
			"[Ton horloge est à l'heure.]\e"
		}
		else //if your clock doesn't match
		{
			"[Ton horloge ne correspond pas.]\n\n"
			--
			"\![*]\q[Régler,OnSNTPExecute]  \![*]\q[La laisser,OnCancel]\e" 
		}
	}
	elseif language == "Polski"
	{
		if reference3 == 0 //if your clock is already accurate.
		{
			"[Twój zegar jest prawidłowy.]\e"
		}
		else //if your clock doesn't match
		{
			"[Twój zegar nie pasuje.]\n\n"
			--
			"\![*]\q[Napraw,OnSNTPExecute]  \![*]\q[Zostaw jak jest,OnCancel]\e" 
		}
	}
	else //English
	{
		if reference3 == 0 //if your clock is already accurate.
		{
			"[Your clock is accurate.]\e"
		}
		else //if your clock doesn't match
		{
			"[Your clock doesn't match.]\n\n"
			--
			"\_q\![*]\q[Fix it,OnSNTPExecute]  \![*]\q[Leave it alone,OnCancel]\e" 
		}
	}
}

//The \6 is what actually changes the clock
OnSNTPExecute
{
	"\0\b[0]"
	--
	if ISFUNC("OnCustom_ActionSurfaces") && CustomFuncs[0] == 1; "\![embed,OnCustom_ActionSurfaces,Action]"
	else; "\s[6]"
	--
	"\6"
	--
	if language == "Placeholder" //TRANSLATORS: Fixing the clock
	{
		
	}
	elseif language == "Español"
	{
		"[El reloj ha sido ajustado.]\e"
	}
	elseif language == "Deutsch"
	{
		"[Deine Uhr wurde richtiggestellt.]\e"
	}
	elseif language == "Русский"
	{
		"[Починил часы.]\e"
	}
	elseif language == "Français"
	{
		"[L'horloge a été réglée.]\e"
	}
	elseif language == "Polski"
	{
		"[Zegar został naprawiony.]\e"
	}
	else //English
	{
		"[The clock has been fixed.]\e"
	}
}

//reference0 is the name of the SNTP server - Note that this may happen before any other STNP dialogue is said! Keep in mind when writing your dialogue that the user will not necessarily have clicked the yes button.
OnSNTPFailure
{
	"\0\b[0]"
	--
	if ISFUNC("OnCustom_ActionSurfaces") && CustomFuncs[0] == 1; "\![embed,OnCustom_ActionSurfaces,Error]"
	else; "\s[6]"
	--
	if language == "Placeholder" //TRANSLATORS: If the SNTP check fails
	{
		
	}
	elseif language == "Español"
	{
		"[No se ha podido obtener la hora.]\e"
	}
	elseif language == "Deutsch"
	{
		"[Die Zeit konnte nicht abgefragt werden.]\e"
	}
	elseif language == "Русский"
	{
		"[Не получил времени.]\e"
	}
	elseif language == "Français"
	{
		"[Impossible de récuperer l'heure.]\e"
	}
	elseif language == "Polski"
	{
		"[Nie udało się odzyskać czasu.]\e"
	}
	else
	{
		"[Couldn't get the time.]\e"
	}
}

//reference0 is the new size, reference1 is the previous size. Sadly, you can't check for the Y scale.
OnShellScaling
{
	nowscale = reference0
}

//Hotkeys. reference0 is the name of the key as displayed on the keycap. reference4, for SSP only, will have things like ctrl and alt, separated by commas.
OnKeyPress
{
	if MusicPlayer.ChangingHotkeys; MusicPlayer.HotkeyChange
	elseif reference0 == "f1"; "\![open,readme]"
	elseif reference0 == "t"; OnAiTalk
	elseif reference0 == "r"; OnLastTalk
	else; MusicPlayer.OnKeyPress
}

OnCancel
{
	OnSurfaceRestore
}